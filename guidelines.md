# guidelines.md — Solenoid Euclidean Drum Machine

## 1. Project Overview

Проект представляет собой автономную драм-машину на базе Raspberry Pi Pico (RP2040), генерирующую ритмы на основе евклидовых алгоритмов. В качестве исполнительных механизмов используются электромеханические соленоиды, управляемые через транзисторные ключи (MOSFET). Устройство ориентировано на live-перформанс с мгновенным тактильным и визуальным откликом.

## 2. Tech Stack

- **Язык**: C++ (Arduino IDE).
- **Ядро**: Raspberry Pi Pico/RP2040 by Earle F. Philhower (необходимо для поддержки многопоточности setup1/loop1).
- **Архитектура**: Dual-Core (Многозадачность):
  - Core 0: Обработка ввода (энкодер, кнопки), логика секвенсора, генерация импульсов для соленоидов.
  - Core 1: Отрисовка графического интерфейса (OLED 128x64) по шине I2C (400 кГц). Строгое использование статических `char` массивов и `snprintf` вместо класса `String` для предотвращения фрагментации кучи (heap).
- **Основные библиотеки**:
  - GyverOLED: Легкая и быстрая отрисовка интерфейса.
  - EncButton: Высокоуровневая обработка кнопок и энкодера с фильтрацией дребезга.
  - EEPROM (RP2040): Эмуляция энергонезависимой памяти для сохранения паттернов и BPM.

## 3. Core Logic (Euclidean Rhythms & Timing)

Ритмы строятся по алгоритму Бьерклунда, оптимизированному для микроконтроллеров.

Формула: $E(k, n, r)$, где $k$ — количество ударов, $n$ — длина цикла (шаги), $r$ — вращение (смещение фазы).

**Глобальная фаза и Независимый Шаффл (Shuffle):**
- Для обеспечения железобетонной синхронизации при изменении параметров используется непрерывно растущий счетчик `absoluteStep`. Положение "курсора" канала вычисляется как `currentStep = absoluteStep % n`.
- **Шаффл (сдвиг слабой доли):** Реализуется через `dynamicInterval`. Четные (сильные) шаги удлиняются на вычисленную дельту (`baseInterval + delta`), нечетные (слабые) — укорачиваются (`baseInterval - delta`). Сумма длительностей двух шагов всегда равна `2 * baseInterval`, что защищает каналы от рассинхронизации друг с другом.
- **Anti-freeze логика:** Защита таймеров секвенсора от отставания или переполнений (`elapsed > baseInterval * 3`).

## 4. Hardware Mapping (Pinout)

| Компонент     | Тип     | GPIO (Pico) | Примечание              |
|---------------|---------|-------------|-------------------------|
| I2C SDA       | Display | 4           | OLED SSD1306            |
| I2C SCL       | Display | 5           | OLED SSD1306            |
| Encoder DT    | Input   | 10          | Подтяжка INPUT_PULLUP   |
| Encoder CLK   | Input   | 11          | Подтяжка INPUT_PULLUP   |
| Encoder SW    | Input   | 12          | Кнопка энкодера         |
| Channel 1 Btn | Input   | 16          | Выбор/Mute/Menu Ch 1    |
| Channel 1 LED | Output  | 17          | Индикация выбора Ch 1   |
| Channel 1 Sol | Output  | 3           | Через MOSFET            |
| Channel 2 Btn | Input   | 18          | Выбор/Mute/Menu Ch 2    |
| Channel 2 LED | Output  | 19          | Индикация выбора Ch 2   |
| Channel 2 Sol | Output  | 2           | Через MOSFET            |
| Channel 3 Btn | Input   | 20          | Выбор/Mute/Menu Ch 3    |
| Channel 3 LED | Output  | 21          | Индикация выбора Ch 3   |
| Channel 3 Sol | Output  | 1           | Через MOSFET            |
| Channel 4 Btn | Input   | 22          | Выбор/Mute/Menu Ch 4    |
| Channel 4 LED | Output  | 26          | Индикация выбора Ch 4   |
| Channel 4 Sol | Output  | 0           | Через MOSFET            |

## 5. Current State (v1.2 - Advanced UI & Timing)

Реализовано:

- Модульная структура проекта (разбиение на .h файлы).
- 4-канальный независимый секвенсор с параметром Shuffle (-50 до +50).
- Трехуровневая система интерфейса (FSM: `SCREEN_MAIN`, `SCREEN_CH_SETTINGS`, `SCREEN_GLOBAL`).
- Мгновенный отклик UI (нулевая задержка кнопок при выборе канала через `.press()`).
- Кастомная попиксельная отрисовка списков меню с динамической инверсией выделения (ровно 10 символов в строке, идеальный стык текста).
- Глобальная математическая синхронизация фаз (`absoluteStep`).
- Умное ускорение энкодера и программная фильтрация дребезга.
- Автосохранение в EEPROM через 3 секунды после последнего изменения.
- Factory Reset (удержание энкодера 3 сек при старте/в процессе).
- Асинхронное управление импульсами соленоидов (неблокирующее).
- Вывод дебаг-логов в Serial (115200 бод) для отслеживания состояний UI и зависаний таймера.

## 6. Known Issues & Constraints

- **Индуктивные выбросы**: Соленоиды требуют обязательного наличия обратных диодов (Flyback diodes) параллельно обмоткам для защиты MOSFET и Pico.
- **Питание**: Пики тока при одновременном ударе нескольких соленоидов могут просаживать линию 3.3V, что ведет к перезагрузке Pico. Рекомендуется раздельное питание силовой и логической части.
- **I2C Latency**: Отрисовка графики (особенно кругов) занимает значительное время, поэтому она строго изолирована на Ядре 1. Сброс флага `needRedraw` должен происходить *до* вызова функции отрисовки во избежание Race Conditions (пропуска кадров).
- **Memory Fragmentation (Куча)**: Из-за специфики двухъядерности и библиотеки I2C, использование динамических строк (`String`) внутри цикла отрисовки может вызывать краш памяти и зависание экрана. Всегда использовать `char[]` и `snprintf`.

## 7. AI Coding Rules (For Gemini)

- **Strict Non-blocking**: Никаких delay(). Использовать millis() или аппаратные таймеры.
- **Modularity First**: Новые функции добавлять в соответствующие модули (Sequencer.h, UI_Display.h и т.д.).
- **Core Isolation**: Логика звука — на Core 0, логика визуала — на Core 1. Не смешивать I2C-команды с генерацией импульсов.
- **Pin Protection**: Не менять Hardware Mapping без прямого запроса пользователя.
- **Preserve Archive**: Устаревшие или экспериментальные алгоритмы комментировать и оставлять в коде с пометкой [ARCHIVE], если не указано иное.
- **Comment Policy**: Обязательно комментировать физические параметры (длительность импульса, пороги ускорения).
- **No `String` Objects**: Строго запрещено использовать класс `String` в файлах UI для предотвращения зависаний. Форматировать текст исключительно через статические массивы `char buf[N]` и функцию `snprintf`.
- **Zero-latency UI**: Для основных смен режимов кнопок (выбор канала) использовать `.press()` вместо кликов, чтобы гарантировать моментальную реакцию без ожидания таймаутов библиотеки кнопок, но с сохранением функционала `hold()` и `hasClicks(2)`.

## 8. Scalability & Expansion

- **Архитектура данных**: Использование константы `NUM_CHANNELS` и массивов структур `Channel` позволяет масштабировать количество дорожек минимальным изменением кода. В структуре предусмотрены зарезервированные слоты `paramA` — `paramD` под новые функции (например, ШИМ-управление или длительность).
- **GPIO Capacity**: Свободные пины RP2040 позволяют расширить систему до 4–6 каналов (соленоид + LED + кнопка) без использования расширителей портов. При использовании только соленоидов возможно управление до 12–16 исполнителей.
- **UI Масштабирование**: Текущий интерфейс сфокусирован на активном канале. При увеличении числа каналов предусмотрена возможность циклического перебора или внедрения компактных статус-баров для неактивных дорожек. Универсальная функция `drawMenuList` легко вмещает новые пункты меню.
- **Память (EEPROM)**: При расширении количества каналов следует учитывать размер структуры `SaveData` и пропорционально увеличивать выделяемый буфер в `EEPROM.begin()`.
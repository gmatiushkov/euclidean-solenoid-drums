\# guidelines.md — Solenoid Euclidean Drum Machine



\## 1. Project Overview



Проект представляет собой автономную драм-машину на базе Raspberry Pi Pico (RP2040), генерирующую ритмы на основе евклидовых алгоритмов. В качестве исполнительных механизмов используются электромеханические соленоиды, управляемые через транзисторные ключи (MOSFET). Устройство ориентировано на live-перформанс с мгновенным тактильным и визуальным откликом.



\## 2. Tech Stack



\- \*\*Язык\*\*: C++ (Arduino IDE).

\- \*\*Ядро\*\*: Raspberry Pi Pico/RP2040 by Earle F. Philhower (необходимо для поддержки многопоточности setup1/loop1).

\- \*\*Архитектура\*\*: Dual-Core (Многозадачность):

&nbsp; - Core 0: Обработка ввода (энкодер, кнопки), логика секвенсора, генерация импульсов для соленоидов.

&nbsp; - Core 1: Отрисовка графического интерфейса (OLED 128x64) по шине I2C (400 кГц).

\- \*\*Основные библиотеки\*\*:

&nbsp; - GyverOLED: Легкая и быстрая отрисовка интерфейса.

&nbsp; - EncButton: Высокоуровневая обработка кнопок и энкодера с фильтрацией дребезга.

&nbsp; - EEPROM (RP2040): Эмуляция энергонезависимой памяти для сохранения паттернов и BPM.



\## 3. Core Logic (Euclidean Rhythms)



Ритмы строятся по алгоритму Бьерклунда, оптимизированному для микроконтроллеров.



Формула: $E(k, n, r)$, где $k$ — количество ударов, $n$ — длина цикла (шаги), $r$ — вращение (смещение фазы).



Глобальная фаза (Global Phase): Положение "курсора" каждого канала вычисляется как $$currentStep = globalStepCounter \\pmod n$$. Это гарантирует, что при изменении $n$ все каналы сохраняют математическую синхронизацию относительно сильной доли.



\## 4. Hardware Mapping (Pinout)



| Компонент     | Тип     | GPIO (Pico) | Примечание              |

|---------------|---------|-------------|-------------------------|

| I2C SDA      | Display | 4          | OLED SSD1306            |

| I2C SCL      | Display | 5          | OLED SSD1306            |

| Encoder DT   | Input   | 10         | Подтяжка INPUT\_PULLUP   |

| Encoder CLK  | Input   | 11         | Подтяжка INPUT\_PULLUP   |

| Encoder SW   | Input   | 12         | Кнопка энкодера         |

| Channel 1 Btn| Input   | 16         | Выбор/Mute Ch 1         |

| Channel 2 Btn| Input   | 17         | Выбор/Mute Ch 2         |

| Solenoid 1   | Output  | 15         | Через MOSFET (Logic Level) |

| Solenoid 2   | Output  | 14         | Через MOSFET (Logic Level) |

| LED 1        | Output  | 18         | Индикация выбора Ch 1   |

| LED 2        | Output  | 19         | Индикация выбора Ch 2   |



\## 5. Current State (v1.1 - Modular Refactor)



Реализовано:



\- Модульная структура проекта (разбиение на .h файлы).

\- Двухканальный независимый секвенсор.

\- Глобальная синхронизация фаз.

\- Умное ускорение энкодера и программная фильтрация дребезга.

\- Автосохранение в EEPROM через 3 секунды после последнего изменения.

\- Factory Reset (удержание энкодера 3 сек при старте/в процессе).

\- Асинхронное управление импульсами соленоидов (неблокирующее).



\## 6. Known Issues \& Constraints



\- \*\*Индуктивные выбросы\*\*: Соленоиды требуют обязательного наличия обратных диодов (Flyback diodes) параллельно обмоткам для защиты MOSFET и Pico.

\- \*\*Питание\*\*: Пики тока при одновременном ударе нескольких соленоидов могут просаживать линию 3.3V, что ведет к перезагрузке Pico. Рекомендуется раздельное питание силовой и логической части.

\- \*\*I2C Latency\*\*: Отрисовка круга занимает значительное время, поэтому она строго изолирована на Ядре 1.



\## 7. AI Coding Rules (For Gemini)



\- \*\*Strict Non-blocking\*\*: Никаких delay(). Использовать millis() или аппаратные таймеры.

\- \*\*Modularity First\*\*: Новые функции добавлять в соответствующие модули (Sequencer.h, UI\_Display.h и т.д.).

\- \*\*Core Isolation\*\*: Логика звука — на Core 0, логика визуала — на Core 1. Не смешивать I2C-команды с генерацией импульсов.

\- \*\*Pin Protection\*\*: Не менять Hardware Mapping без прямого запроса пользователя.

\- \*\*Preserve Archive\*\*: Устаревшие или экспериментальные алгоритмы комментировать и оставлять в коде с пометкой \[ARCHIVE], если не указано иное.

\- \*\*Comment Policy\*\*: Обязательно комментировать физические параметры (длительность импульса, пороги ускорения).



\## 8. Scalability \& Expansion



\- \*\*Архитектура данных\*\*: Использование константы `NUM\_CHANNELS` и массивов структур `Channel` позволяет масштабировать количество дорожек минимальным изменением кода.

\- \*\*GPIO Capacity\*\*: Свободные пины RP2040 позволяют расширить систему до 4–6 каналов (соленоид + LED + кнопка) без использования расширителей портов. При использовании только соленоидов возможно управление до 12–16 исполнителей.

\- \*\*UI Масштабирование\*\*: Текущий интерфейс сфокусирован на активном канале. При увеличении числа каналов предусмотрена возможность циклического перебора или внедрения компактных статус-баров для неактивных дорожек.

\- \*\*Память (EEPROM)\*\*: При расширении количества каналов следует учитывать размер структуры `SaveData` и пропорционально увеличивать выделяемый буфер в `EEPROM.begin()`.

